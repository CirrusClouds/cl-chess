(in-package #:cl-chess)

(defmethod lookup-wpawn-moves (square (cb chessboard))
  "Takes a square and finds the valid squares a white pawn could move to."
  (multiple-value-bind (y x) (floor square 8)
    (cond ((= x 0)
           (list (+ (* 8 (+ y 1)) x)
                 (+ (* 8 (+ y 2)) x)
                 (+ (* 8 (+ y 1)) (+ x 1))))
          ((= x 7)
           (list (+ (* 8 (+ y 1)) x)
                 (+ (* 8 (+ y 2)) x)
                 (+ (* 8 (+ y 1)) (- x 1))))
          (t
           (list (+ (* 8 (+ y 1)) x)
                 (+ (* 8 (+ y 2)) x)
                 (+ (* 8 (+ y 1)) (- x 1))
                 (+ (* 8 (+ y 1)) (+ x 1))))
          )))

(defmethod lookup-bpawn-moves (square (cb chessboard))
  "Takes a square and finds the valid squares a black pawn could move to."
  (multiple-value-bind (y x) (floor square 8)
    (cond ((= x 0)
           (list (+ (* 8 (- y 1)) x)
                 (+ (* 8 (- y 2)) x)
                 (+ (* 8 (- y 1)) (+ x 1))))
          ((= x 7)
           (list (+ (* 8 (- y 1)) x)
                 (+ (* 8 (- y 2)) x)
                 (+ (* 8 (- y 1)) (- x 1))))
          (t
           (list (+ (* 8 (- y 1)) x)
                 (+ (* 8 (- y 2)) x)
                 (+ (* 8 (- y 1)) (- x 1))
                 (+ (* 8 (- y 1)) (+ x 1))))
          )))

(defmethod lookup-knight-moves (square (cb chessboard))
  "Takes a square and finds the valid squares a knight could move to"
  (multiple-value-bind (y x) (floor square 8)
    (let ((hops (list (list (+ y 1) (+ x 2))
                      (list (+ y 1) (- x 2))
                      (list (+ y 2) (+ x 1))
                      (list (+ y 2) (- x 1))
                      (list (- y 1) (+ x 2))
                      (list (- y 1) (- x 2))
                      (list (- y 2) (+ x 1))
                      (list (- y 2) (- x 1)))))
      (mapcar (lambda (coord)
                (+ (* 8 (first coord)) (second coord)))
              (remove-if-not (lambda (coord)
                               (and (>= (first coord) 0)
                                    (>= (second coord) 0)
                                    (<= (first coord) 7)
                                    (<= (second coord) 7)))
                             hops)))))

(defmethod sliding-attack (square directions (cb chessboard))
  "Sliding attack algorithm for sliding pieces"
  (multiple-value-bind (y x) (floor square 8)
    (labels ((slide1 (x y di &optional (acc nil))
               (let ((coord (mapcar (lambda (x1 x2) (+ x1 x2)) di (list x y))))
                 (if (and (>= (first coord) 0)
                          (>= (second coord) 0)
                          (<= (first coord) 7)
                          (<= (second coord) 7))
                     (cond ((equal 0
                                   (find-piece-on-square
                                    (+ (first coord) (* 8 (second coord)))
                                    (slot-value cb 'bitboards)))
                            (slide1 (first coord) (second coord) di (append acc (list coord))))
                           ((player-piece-p cb (find-piece-on-square (+ (first coord) (* 8 (second coord)))
                                                                     (slot-value cb 'bitboards)))
                            acc)
                           (t
                            (append acc (list coord))))
                     acc))))
      (mapcar (lambda (coord)
                (+ (first coord) (* 8 (second coord)))) (mapcan (lambda (di)
                                                                  (slide1 x y di)) directions)))))

(defmethod lookup-bishop-moves (square (cb chessboard))
"Takes a square and finds the valid squares a bishop could move to. Requires a sliding attack algorithm."
  (let ((directions (list (list 1 1)
                          (list -1 -1)
                          (list 1 -1)
                          (list -1 1))))
    (sliding-attack square directions cb)))

(defmethod lookup-rook-moves (square (cb chessboard))
  "Takes a square and finds the valid squares a rook could move to. Also requires a sliding attack algorithm."
  (let ((directions (list (list 0 1)
                          (list 0 -1)
                          (list 1 0)
                          (list -1 0))))
    (sliding-attack square directions cb)))

(defmethod lookup-queen-moves (square (cb chessboard))
  "Takes a square and finds the valid squares a queen could move to"
  (append (lookup-bishop-moves square cb)
          (lookup-rook-moves square cb)))

(defmethod lookup-king-moves (square (cb chessboard))
  "Takes a square and finds the valid squares a king could move to"
  (multiple-value-bind (y x) (floor square 8)
    (let* ((possible-squares (list
                              (list (- y 1) x)
                              (list y (- x 1))
                              (list y (+ x 1))
                              (list (- y 1) (+ x 1))
                              (list (- y 1) (- x 1))
                              (list (+ y 1) (+ x 1))
                              (list (+ y 1) x)
                              (list (+ y 1) (- x 1))))

           (in-bound-squares (remove-if-not (lambda (coords)
                                          (and (< (first coords) 8)
                                               (> (first coords) 0)
                                               (< (second coords) 8)
                                               (> (first coords) 0))) possible-squares)))
      (mapcar (lambda (coords)
                (+ (* (first coords) 8)
                   (second coords))) in-bound-squares))))

(defmethod lookup-attack-squares (square sym (cb chessboard))
  (let ((lookup-func
          (ccase sym
            ('WN #'lookup-knight-moves)
            ('WB #'lookup-bishop-moves)
            ('WP #'lookup-wpawn-moves)
            ('WR #'lookup-rook-moves)
            ('WK #'lookup-king-moves)
            ('WQ #'lookup-queen-moves)
            ('BP #'lookup-bpawn-moves)
            ('BN #'lookup-knight-moves)
            ('BB #'lookup-bishop-moves)
            ('BR #'lookup-rook-moves)
            ('BQ #'lookup-queen-moves)
            ('BK #'lookup-king-moves))
          ))
    (funcall lookup-func square cb)))
